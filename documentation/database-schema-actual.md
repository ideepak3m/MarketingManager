# Database Schema - Marketing Manager

This document outlines the database schema requirements based on the actual n8n workflow implementation.

## Primary Table: campaign_capture_byNova

This is the main table used by the n8n workflow to store Nova's campaign outputs.

### Table Structure

```sql
CREATE TABLE campaign_capture_byNova (
    id SERIAL PRIMARY KEY,
    campaign JSONB NOT NULL,
    summaryText TEXT,
    missingFields JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

### Field Descriptions

#### campaign (JSONB)
Stores the complete JSON payload generated by Nova, containing:

**Campaign Object Structure:**
```json
{
  "campaign": {
    "name": "Campaign name generated by Nova",
    "description": "Campaign description and objectives", 
    "campaign_type": "product_launch|brand_awareness|lead_generation|sales|event_promotion",
    "status": "planned",
    "start_date": "ISO 8601 format",
    "end_date": "ISO 8601 format", 
    "budget": "User-specified budget",
    "target_audience": "Target audience description",
    "goals": "Campaign goals and objectives",
    "target_metrics": {
      "reach": 20000,
      "engagement_rate": "3%",
      "phase_specific_kpis": "Success metrics defined by Nova"
    },
    "platforms": ["instagram", "facebook", "linkedin", "twitter", "tiktok"],
    "number_of_phases": 3
  },
  "campaign_phases": [
    {
      "name": "Phase name generated by Nova",
      "description": "What this phase accomplishes",
      "phase_order": 1,
      "start_date": "ISO 8601 format",
      "end_date": "ISO 8601 format", 
      "status": "planned",
      "goals": {
        "description": "Phase-specific goals",
        "content_strategy": "Content recommendations",
        "recommended_content_types": ["image", "story", "post", "reel", "video"],
        "recommended_platforms": ["instagram", "facebook"]
      },
      "target_metrics": {
        "reach": 20000,
        "engagement_rate": "3%",
        "phase_specific_kpis": "Phase success metrics"
      }
    }
  ]
}
```

#### summaryText (TEXT)
Contains the human-readable campaign summary that Nova provides to users, with the JSON payload stripped out. This is the conversational explanation of the campaign that users see in the chat.

#### missingFields (JSONB)
Array of field paths that failed validation during the n8n workflow processing. Examples:
```json
[
  "campaign.budget",
  "campaign.target_audience", 
  "campaign_phases[0].start_date",
  "Mismatch: campaign.number_of_phases (3) vs campaign_phases.length (2)"
]
```

### Indexes

```sql
-- Index for querying by campaign creation time
CREATE INDEX idx_campaign_capture_created_at ON campaign_capture_byNova(created_at);

-- Index for querying campaign types
CREATE INDEX idx_campaign_type ON campaign_capture_byNova USING GIN ((campaign->'campaign'->>'campaign_type'));

-- Index for full-text search on summary
CREATE INDEX idx_summary_text_search ON campaign_capture_byNova USING GIN (to_tsvector('english', summaryText));

-- Index for campaigns with validation issues
CREATE INDEX idx_campaigns_with_issues ON campaign_capture_byNova USING GIN (missingFields) WHERE missingFields IS NOT NULL AND jsonb_array_length(missingFields) > 0;
```

### Database Functions

#### Get Campaign with Validation Status
```sql
CREATE OR REPLACE FUNCTION get_campaign_with_status(campaign_id INTEGER)
RETURNS TABLE (
    id INTEGER,
    campaign JSONB,
    summary_text TEXT,
    has_validation_issues BOOLEAN,
    validation_issues JSONB,
    phase_count INTEGER,
    created_at TIMESTAMP WITH TIME ZONE
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        c.id,
        c.campaign,
        c.summaryText,
        (c.missingFields IS NOT NULL AND jsonb_array_length(c.missingFields) > 0) as has_validation_issues,
        c.missingFields,
        COALESCE(jsonb_array_length(c.campaign->'campaign_phases'), 0) as phase_count,
        c.created_at
    FROM campaign_capture_byNova c
    WHERE c.id = campaign_id;
END;
$$ LANGUAGE plpgsql;
```

#### Get Campaigns by Type
```sql
CREATE OR REPLACE FUNCTION get_campaigns_by_type(campaign_type TEXT)
RETURNS TABLE (
    id INTEGER,
    name TEXT,
    description TEXT,
    start_date TEXT,
    phase_count INTEGER,
    created_at TIMESTAMP WITH TIME ZONE
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        c.id,
        c.campaign->'campaign'->>'name' as name,
        c.campaign->'campaign'->>'description' as description,
        c.campaign->'campaign'->>'start_date' as start_date,
        COALESCE(jsonb_array_length(c.campaign->'campaign_phases'), 0) as phase_count,
        c.created_at
    FROM campaign_capture_byNova c
    WHERE c.campaign->'campaign'->>'campaign_type' = campaign_type
    ORDER BY c.created_at DESC;
END;
$$ LANGUAGE plpgsql;
```

## API Endpoints for React Integration

Based on the workflow implementation, the React app needs these API endpoints:

### GET /api/campaigns
Returns list of all captured campaigns with basic information:
```json
[
  {
    "id": 1,
    "name": "Holiday Product Launch",
    "campaign_type": "product_launch", 
    "phase_count": 3,
    "created_at": "2025-10-16T10:30:00Z",
    "has_validation_issues": false
  }
]
```

### GET /api/campaigns/:id
Returns complete campaign details including JSON payload and summary:
```json
{
  "id": 1,
  "campaign": { /* complete Nova JSON payload */ },
  "summaryText": "This campaign focuses on...",
  "missingFields": [],
  "created_at": "2025-10-16T10:30:00Z"
}
```

### GET /api/campaigns/types/:type
Returns campaigns filtered by campaign_type (product_launch, brand_awareness, etc.)

## Row Level Security (RLS)

If using multi-tenant setup, implement RLS policies:

```sql
-- Enable RLS
ALTER TABLE campaign_capture_byNova ENABLE ROW LEVEL SECURITY;

-- Policy for user access (if user_id field is added)
CREATE POLICY "Users can access their own campaigns" ON campaign_capture_byNova
    FOR ALL USING (auth.uid() = user_id);

-- Policy for service role (for n8n workflow)
CREATE POLICY "Service role full access" ON campaign_capture_byNova
    FOR ALL TO service_role USING (true);
```

## Migration Script

```sql
-- Create the main table
CREATE TABLE IF NOT EXISTS campaign_capture_byNova (
    id SERIAL PRIMARY KEY,
    campaign JSONB NOT NULL,
    summaryText TEXT,
    missingFields JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Add indexes
CREATE INDEX IF NOT EXISTS idx_campaign_capture_created_at ON campaign_capture_byNova(created_at);
CREATE INDEX IF NOT EXISTS idx_campaign_type ON campaign_capture_byNova USING GIN ((campaign->'campaign'->>'campaign_type'));
CREATE INDEX IF NOT EXISTS idx_summary_text_search ON campaign_capture_byNova USING GIN (to_tsvector('english', summaryText));

-- Add trigger for updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_campaign_capture_updated_at 
    BEFORE UPDATE ON campaign_capture_byNova 
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
```

This schema supports the complete n8n workflow while providing flexibility for the React frontend to query and display campaign data effectively.